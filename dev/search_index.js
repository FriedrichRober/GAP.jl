var documenterSearchIndex = {"docs":
[{"location":"#GAP.jl-1","page":"GAP.jl","title":"GAP.jl","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"CurrentModule = GAP","category":"page"},{"location":"#Introduction-1","page":"GAP.jl","title":"Introduction","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"GAP.jl is a low level interface from Julia to the computer algebra system GAP. The term \"low level\" means that the aim is to give Julia access to all GAP objects, to let Julia call GAP functions, and to provide conversions of low level data (integers, Booleans, strings, arrays/lists, dictionaries/records) between the two systems.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"In particular, it is not the aim of GAP.jl to provide Julia types for higher level GAP objects that represent algebraic structures, such as groups, rings, fields, etc., and mappings between such structures.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"The connection between GAP and Julia is in fact bidirectional, that is, GAP can access all Julia objects, call Julia functions, and perform conversions of low level data. This direction will become interesting on the Julia side as soon as GAP packages provide functionality that is based on using Julia code from the GAP side.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"The viewpoint of an interface from GAP to Julia is described in the manual of the GAP package JuliaInterface.","category":"page"},{"location":"#Types-1","page":"GAP.jl","title":"Types","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"FFE\nGapObj","category":"page"},{"location":"#GAP.FFE","page":"GAP.jl","title":"GAP.FFE","text":"FFE\n\nWrap a pointer to a GAP FFE (\"finite field element\") immediate object. This type is defined in the JuliaInterface C code.\n\nExamples\n\njulia> x = GAP.evalstr( \"Z(3)\" )\nGAP: Z(3)\n\njulia> typeof( x )\nFFE\n\n\n\n\n\n\n","category":"type"},{"location":"#GAP.GapObj","page":"GAP.jl","title":"GAP.GapObj","text":"GapObj\n\nThis is the Julia type of all those GAP objects that are not \"immediate\" (Booleans, small integers, FFEs).\n\nExamples\n\njulia> isa( GAP.evalstr( \"[ 1, 2 ]\" ), GAP.GapObj ) # a GAP list\ntrue\n\njulia> isa( GAP.evalstr( \"rec()\" ), GAP.GapObj )    # a GAP record\ntrue\n\njulia> isa( GAP.evalstr( \"(1,2,3)\" ), GAP.GapObj )  # a GAP permutation\ntrue\n\njulia> isa( GAP.evalstr( \"2^64\" ), GAP.GapObj )     # a large GAP integer\ntrue\n\njulia> typeof( GAP.evalstr( \"2^59\" ) )              # a small GAP integer\nInt64\n\njulia> typeof( GAP.evalstr( \"Z(2)\" ) )              # a GAP FFE\nFFE\n\njulia> typeof( GAP.evalstr( \"true\" ) )              # a Boolean\nBool\n\n\nNote that this is Julia's viewpoint on GAP objects. From the viewpoint of GAP, also the pointers to Julia objects are implemented as \"non-immediate GAP objects\", but they appear as Julia objects to Julia, not \"doubly wrapped\".\n\nExamples\n\njulia> GAP.evalstr( \"Julia.Base\" )\nBase\n\njulia> typeof( GAP.evalstr( \"Julia.Base\" ) )        # native Julia object\nModule\n\n\n\n\n\n\n","category":"type"},{"location":"#Macros-1","page":"GAP.jl","title":"Macros","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"@gap\n@g_str","category":"page"},{"location":"#GAP.@gap","page":"GAP.jl","title":"GAP.@gap","text":"@gap <expr>\n@gap(<expr>)\n\nExecute <expr> directly in GAP, as if GAP.evalstr(\"<expr>\") was called. This can be used for creating GAP literals directly from Julia.\n\nExamples\n\njulia> @gap [1,2,3]\nGAP: [ 1, 2, 3 ]\n\njulia> @gap SymmetricGroup(3)\nGAP: Sym( [ 1 .. 3 ] )\n\njulia> @gap(SymmetricGroup)(3)\nGAP: Sym( [ 1 .. 3 ] )\n\n\nNote that the last two examples have a slight syntactical, and therefore also a semantical difference. The first one executes the string SymmetricGroup(3) directly inside GAP. The second example returns the function SymmetricGroup via @gap(SymmetricGroup), then calls that function with the argument 3.\n\nDue to Julia's way of handing over arguments into the code of macros, not all expressions representing valid GAP code can be processed. For example, the GAP syntax of permutations consisting of more than one cycle cause problems, as well as the GAP syntax of non-dense lists.\n\njulia> @gap (1,2,3)\nGAP: (1,2,3)\n\njulia> @gap (1,2)(3,4)\nERROR: LoadError: Error thrown by GAP: Error, no method found! For debugging hints type ?Recovery from NoMethodFound\n[...]\n\njulia> @gap [ 1,, 2 ]\nERROR: syntax: unexpected \",\"\n[...]\n\n\nNote also that a string argument gets evaluated with GAP.evalstr.\n\njulia> @gap \"\\\"abc\\\"\"\nGAP: \"abc\"\n\njulia> @gap \"[1,,2]\"\nGAP: [ 1,, 2 ]\n\njulia> @gap \"(1,2)(3,4)\"\nGAP: (1,2)(3,4)\n\n\n\n\n\n\n","category":"macro"},{"location":"#GAP.@g_str","page":"GAP.jl","title":"GAP.@g_str","text":"@g_str\n\nCreate a GAP string by typing g\"content\".\n\nExamples\n\njulia> g\"foo\"\nGAP: \"foo\"\n\n\n\n\n\n","category":"macro"},{"location":"#Conversions-1","page":"GAP.jl","title":"Conversions","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"gap_to_julia\njulia_to_gap","category":"page"},{"location":"#GAP.gap_to_julia","page":"GAP.jl","title":"GAP.gap_to_julia","text":"gap_to_julia(type, x, recursion_dict=nothing; recursive=true)\n\nTry to convert the object x to a Julia object of type type. If x is a GAP.GapObj then the conversion rules are defined in the manual of the GAP package JuliaInterface. If x is another GAP.Obj (for example a Int64) then the result is defined in Julia by type.\n\nThe parameter recursion_dict is meant to preseve the identity of converted subobjects and should never be given by the user.\n\nFor GAP lists and records, it makes sense to convert also the subobjects recursively, or to keep the subobjects as they are; the behaviour is controlled by recursive, which can be true or false.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.julia_to_gap","page":"GAP.jl","title":"GAP.julia_to_gap","text":"julia_to_gap(input, recursive::Val{Recursive} = Val(false), recursion_dict = IdDict())\n\nConvert a julia object input to an appropriate GAP object. If recursive is set to Val(true), recursive conversions on arrays, tuples, and dictionaries is performed.\n\nThe input recursive_data should never be set by the user, it is meant to keep egality of input data, by converting egal data to identical objects in GAP.\n\n\n\n\n\n","category":"function"},{"location":"#Convenience-adapters-1","page":"GAP.jl","title":"Convenience adapters","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"This section describes how one can manipulate GAP objects from the Julia side, using Julia syntax features.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"Globals\ncall_gap_func\nevalstr\ngetindex\nsetindex!\ngetproperty\nsetproperty!\nhasproperty","category":"page"},{"location":"#GAP.Globals","page":"GAP.jl","title":"GAP.Globals","text":"Globals\n\nThis is a global object that gives access to all global variables of the current GAP session via getproperty and setproperty!.\n\nExamples\n\njulia> GAP.Globals.Size    # a global GAP function\nGAP: <Attribute \"Size\">\n\njulia> GAP.Globals.size    # there is no GAP variable with this name\nERROR: GAP variable size not bound\n[...]\n\njulia> hasproperty( GAP.Globals, :size )\nfalse\n\njulia> GAP.Globals.size = 17;\n\njulia> hasproperty( GAP.Globals, :size )\ntrue\n\njulia> GAP.Globals.size\n17\n\njulia> GAP.Globals.Julia   # Julia objects can be values of GAP variables\nMain\n\n\n\n\n\n\n","category":"constant"},{"location":"#GAP.call_gap_func","page":"GAP.jl","title":"GAP.call_gap_func","text":"call_gap_func(func::GapObj, args...; kwargs...)\n\nCall the GAP object func as a function, with arguments args... and global GAP options kwargs..., and returns the result if there is one, and nothing otherwise.\n\nThere is no argument number checking here, all checks on the arguments are done by GAP itself.\n\nFor convenience, one can use the syntax func(args...; kwargs...).\n\nExamples\n\njulia> GAP.Globals.Factors( 12 )\nGAP: [ 2, 2, 3 ]\n\njulia> g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 )\nGAP: Group([ (1,2), (3,4), (1,3)(2,4), (5,6) ])\n\njulia> GAP.Globals.StructureDescription( g )\nGAP: \"C2 x D8\"\n\njulia> g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 );\n\njulia> GAP.Globals.StructureDescription( g, short = true )\nGAP: \"2xD8\"\n\n\n\n\n\n\n","category":"function"},{"location":"#GAP.evalstr","page":"GAP.jl","title":"GAP.evalstr","text":"evalstr(cmd::String)\n\nLet GAP execute the command(s) given by cmd; if the last command has a result then return it, otherwise return nothing.\n\nExamples\n\njulia> GAP.evalstr( \"1+2\" )\n3\n\njulia> GAP.evalstr( \"x:= []\" )\nGAP: [  ]\n\njulia> GAP.evalstr( \"y:= 2; Add( x, 1 )\" )\n\njulia> GAP.evalstr( \"x\" )\nGAP: [ 1 ]\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.getindex","page":"GAP.jl","title":"Base.getindex","text":"getindex(x::GapObj, i::Int64)\ngetindex(x::GapObj, i::Int64, j::Int64)\ngetindex(x::GapObj, l::Union{Vector{T},AbstractRange{T}}) where {T<:Integer}\n\nReturn the entry at position i or at position (i,j) in x, or the list of entries in x at the positions described by l, provided that x is a GAP list.\n\nExamples\n\njulia> l = GAP.evalstr( \"[ 1, 2, 3, 5, 8, 13 ]\" )\nGAP: [ 1, 2, 3, 5, 8, 13 ]\n\njulia> l[4]\n5\n\njulia> l[end]\n13\n\njulia> l[2:4]\nGAP: [ 2, 3, 5 ]\n\njulia> l[[1,4,4]]\nGAP: [ 1, 5, 5 ]\n\njulia> m = GAP.evalstr( \"[ [ 1, 2 ], [ 3, 4 ] ]\" )\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> m[1,1]\n1\n\njulia> m[1,2]\n2\n\njulia> m[2,1]\n3\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.setindex!","page":"GAP.jl","title":"Base.setindex!","text":"setindex!(x::GapObj, v::Any, i::Int64)\nsetindex!(x::GapObj, v::Any, i::Int64, j::Int64)\nsetindex!(x::GapObj, v::Any, l::Union{Vector{T},AbstractRange{T}}) where {T<:Integer}\n\nSet the entry at position i or (i,j) in x to v, or set the entries at the positions in x that are described by l to the entries in v, provided that x is a GAP list.\n\nExamples\n\njulia> l = GAP.evalstr( \"[ 1, 2, 3, 5, 8, 13 ]\" )\nGAP: [ 1, 2, 3, 5, 8, 13 ]\n\njulia> l[1] = 0\n0\n\njulia> l[8] = -1\n-1\n\njulia> l[2:4] = [ 7, 7, 7 ]\n3-element Array{Int64,1}:\n 7\n 7\n 7\n\njulia> l\nGAP: [ 0, 7, 7, 7, 8, 13,, -1 ]\n\njulia> m = GAP.evalstr( \"[ [ 1, 2 ], [ 3, 4 ] ]\" )\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> m[1,2] = 0\n0\n\njulia> m\nGAP: [ [ 1, 0 ], [ 3, 4 ] ]\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.getproperty","page":"GAP.jl","title":"Base.getproperty","text":"getproperty(x::GapObj, f::Symbol)\ngetproperty(x::GapObj, f::Union{AbstractString,Int64})\n\nReturn the record component of the GAP record x that is described by f.\n\nExamples\n\njulia> r = GAP.evalstr( \"rec( a:= 1 )\" )\nGAP: rec( a := 1 )\n\njulia> r.a\n1\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.setproperty!","page":"GAP.jl","title":"Base.setproperty!","text":"setproperty!(x::GapObj, f::Symbol, v)\nsetproperty!(x::GapObj, f::Union{AbstractString,Int64}, v)\n\nSet the record component of the GAP record x that is described by f to the value v.\n\nExamples\n\njulia> r = GAP.evalstr( \"rec( a:= 1 )\" )\nGAP: rec( a := 1 )\n\njulia> r.b = 0\n0\n\njulia> r\nGAP: rec( a := 1, b := 0 )\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.hasproperty","page":"GAP.jl","title":"Base.hasproperty","text":"hasproperty(x::GapObj, f::Symbol)\nhasproperty(x::GapObj, f::Union{AbstractString,Int64})\n\nReturn true if the GAP record x has a component that is described by f, and false otherwise.\n\nExamples\n\njulia> r = GAP.evalstr( \"rec( a:= 1 )\" )\nGAP: rec( a := 1 )\n\njulia> hasproperty( r, :a )\ntrue\n\njulia> hasproperty( r, :b )\nfalse\n\njulia> r.b = 2\n2\n\njulia> hasproperty( r, :b )\ntrue\n\njulia> r\nGAP: rec( a := 1, b := 2 )\n\n\n\n\n\n\n","category":"function"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"For the following Julia functions, methods are provided that deal with the case that the arguments are GAP objects; they delegate to the corresponding GAP operations.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"Julia GAP\nlength Length\nin \\in\nzero ZERO\none ONE\n- (unary) AINV\n+ SUM\n- (binary) DIFF\n* PROD\n/ QUO\n\\ LQUO\n^ POW\nmod MOD\n< LT\n== EQ","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"julia> l = GAP.julia_to_gap( [ 1, 3, 7, 15 ] )\nGAP: [ 1, 3, 7, 15 ]\n\njulia> m = GAP.julia_to_gap( [ 1 2; 3 4 ] )\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> length( l )\n4\n\njulia> length( m )  # different from Julia's behaviour\n2\n\njulia> 1 in l\ntrue\n\njulia> 2 in l\nfalse\n\njulia> zero( l )\nGAP: [ 0, 0, 0, 0 ]\n\njulia> one( m )\nGAP: [ [ 1, 0 ], [ 0, 1 ] ]\n\njulia> - l\nGAP: [ -1, -3, -7, -15 ]\n\njulia> l + 1\nGAP: [ 2, 4, 8, 16 ]\n\njulia> l + l\nGAP: [ 2, 6, 14, 30 ]\n\njulia> m + m\nGAP: [ [ 2, 4 ], [ 6, 8 ] ]\n\njulia> 1 - m\nGAP: [ [ 0, -1 ], [ -2, -3 ] ]\n\njulia> l * l\n284\n\njulia> l * m\nGAP: [ 10, 14 ]\n\njulia> m * m\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> 1 / m\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> m / 2\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> 2 \\ m\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> m ^ 2\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> m ^ -1\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> mod( l, 3 )\nGAP: [ 1, 0, 1, 0 ]\n\njulia> m < 2 * m\ntrue\n\njulia> m^2 - 5 * m == 2 * one( m )\ntrue\n","category":"page"},{"location":"#Access-to-the-GAP-help-system-1","page":"GAP.jl","title":"Access to the GAP help system","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"show_GAP_help","category":"page"},{"location":"#Managing-GAP-packages-1","page":"GAP.jl","title":"Managing GAP packages","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"The following functions allow one to load/install/update/remove GAP packages.","category":"page"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"GAP.Packages.load\nGAP.Packages.install\nGAP.Packages.update\nGAP.Packages.remove","category":"page"},{"location":"#GAP.Packages.load","page":"GAP.jl","title":"GAP.Packages.load","text":"load(spec::String, version::String = \"\")\n\nTry to load the newest installed version of the GAP package with name spec. Return true if this is successful, and false otherwise.\n\nThe function calls GAP's LoadPackage function; the package banner is not printed.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.install","page":"GAP.jl","title":"GAP.Packages.install","text":"install(spec::String, interactive::Bool = true)\n\nDownload and install the newest released version of the GAP package given by spec in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT). Return true if the installation is successful or if the package was already installed, and false otherwise.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nThe function uses the function InstallPackage from GAP's package PackageManager.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.update","page":"GAP.jl","title":"GAP.Packages.update","text":"update(spec::String)\n\nUpdate the GAP package given by spec that is installed in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT), to the latest version. Return true if a newer version was installed successfully, or if no newer version is available, and false otherwise.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nThe function uses the function UpdatePackage from GAP's package PackageManager.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.remove","page":"GAP.jl","title":"GAP.Packages.remove","text":"remove(spec::String)\n\nRemove the GAP package with name spec that is installed in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT). Return true if the removal was successful, and false otherwise.\n\nThe function uses the function RemovePackage from GAP's package PackageManager.\n\n\n\n\n\n","category":"function"},{"location":"#Other-1","page":"GAP.jl","title":"Other","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"GAP.prompt","category":"page"},{"location":"#GAP.prompt","page":"GAP.jl","title":"GAP.prompt","text":"prompt()\n\nStart a GAP prompt where you can enter GAP commands as in a regular GAP session. This prompt can be left as any GAP prompt by either entering quit; or pressing ctrl-D, which returns to the Julia prompt.\n\nThis GAP prompt allows to quickly switch between writing Julia and GAP code in a session where all data is shared.\n\n\n\n\n\n","category":"function"},{"location":"#Index-1","page":"GAP.jl","title":"Index","text":"","category":"section"},{"location":"#","page":"GAP.jl","title":"GAP.jl","text":"","category":"page"}]
}
